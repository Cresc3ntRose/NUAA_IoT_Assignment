# 本周作业

---

## 作业1
* 一般操作系统中，进程的每个段内部地址均连续，但段与段的相对次序可能不同.
* 用 C/CPP 语言写一个探测程序，探测 Windows、Linux 操作系统中进程的各段的相对位置(输出次序即可).

#### solution:
在 Linux 系统下，以进程 `System` 为例，其 pid 为 1，查看`proc/1/maps` 文件，我们可以看到[其内容](./maps.txt).

不难发现，`maps` 文件中的地址呈现是由小到大的，所以在 Linux 系统下，我们按照地址从小到大的次序依次输出各段.

在文件中，我们可以很轻易地发现`[heap]`与`[stack]`字样，不难推断出这就是堆与栈的所在地址. 同时通过查阅资料，可以得知：
* 代码段通常以 `r-xp` 的权限标记出现.
* 数据段通常以 `r--p` 的权限标记出现.
* BSS段通常以 `rw-p` 的权限标记出现.

于是我们不难得到如下思路：
* 打开 `/proc/1/maps` 文件并查看其内容，然后进行查询.
* 当查询到 `r-xp` 时，就输出 `text`，随后不再处理 `r-xp`.
* 当查询到 `r--p` 时，就输出 `data`，随后不再处理 `r--p`.
* 当查询到 `rw-p` 时，就输出 `BSS`，随后不再处理 `rw-p`.
* 当查询到 `[heap]` 时，就输出 `heap`，随后不再处理 `[heap]`.
* 当查询到 `[stack]` 时，就输出 `stack`，随后不再处理 `[steak]`.

而在 Windows 系统下，我们可以直接调用系统提供的API—— `Windows.h` 库来获得我们想要的信息：
* `GetCurrentProcess()` 函数可以获得当前进程的句柄.
* `VirtualQuery()` 函数会查询指定地址的内存区域信息，并将结果存储在 `MEMORY_BASIC_INFORMATION` 结构体 `mbi` 中.
* 对于代码段的内存区域来说，其 `mbi.Protect`(保护属性) 是 `PAGE_EXECUTE_READ`.
* 若内存区域的保护属性是 `PAGE_READWRITE`，则为数据段.
* 在Windows中，未初始化的全局和静态变量一般被放在数据段中，并且被初始化为零.

根据内存区域的保护属性 mbi.Protect 的不同，将内存区域的基地址 mbi.BaseAddress 存入 segments 数组中。如果是可执行的内存，或者是可读写的内存，或者是只读的内存，都会被记录下来。

每次循环结束后，将 addr 更新为下一个内存区域的起始地址，以便下一次调用 VirtualQuery

---

## 作业2
* 实现一程序，分别在 Windows、Linux 操作系统下验证：
  * 栈、堆、数据区是否可读可写不可执行.
  * 代码段是否可读可写不可执行.