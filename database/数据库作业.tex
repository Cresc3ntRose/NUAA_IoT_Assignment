% \documentclass[12pt, a4paper, oneside]{ctexart}
\documentclass[12pt, oneside]{ctexart}
\usepackage{amsmath, amsthm, amssymb, bm, color, enumerate, framed, graphicx, longtable, mathrsfs, subfigure, tikz}
% \usepackage[dvipsnames]{xcolor}
% \usepackage{geometry}
\usepackage[a4paper, total={145mm,210mm}]{geometry}
\geometry{left=2.54cm,right=2.54cm,top=3.18cm,bottom=3.18cm}
\usepackage{pdfpages}

%按章节编号
\numberwithin{figure}{section}
\numberwithin{table}{section}

% 超链接设置
\usepackage{hyperref}
\hypersetup{  
    colorlinks = true,    % 更改链接颜色  
    linkcolor = black,      % 链接颜色  
    urlcolor = blue,        % URL 颜色  
    citecolor = green,     % 引用颜色  
    % underline = true,  
    linkbordercolor = red,
}
% \hypersetup{colorlinks=true,linkcolor=black}


%代码包设置
\usepackage{listings}
\lstset{
    basicstyle          =   \sffamily,          % 基本代码风格
    keywordstyle        =   \bfseries,          % 关键字风格
    commentstyle        =   \rmfamily\itshape,  % 注释的风格，斜体
    stringstyle         =   \ttfamily,  % 字符串风格
    flexiblecolumns,                % 别问为什么，加上这个
    numbers             =   left,   % 行号的位置在左边
    showspaces          =   false,  % 是否显示空格，显示了有点乱，所以不现实了
    numberstyle         =   \zihao{-5}\ttfamily,    % 行号的样式，小五号，tt等宽字体
    showstringspaces    =   false,
    captionpos          =   t,      % 这段代码的名字所呈现的位置，t指的是top上面
    frame               =   lrtb,   % 显示边框
}
% \lstdefinestyle{C}{
%     language        =   C, % 语言选C
%     basicstyle      =   \zihao{-5}\ttfamily,
%     numberstyle     =   \zihao{-5}\ttfamily,
%     keywordstyle    =   \color{blue},
%     keywordstyle    =   [2] \color{teal},
%     stringstyle     =   \color{magenta},
%     commentstyle    =   \color{red}\ttfamily,
%     breaklines      =   true,   % 自动换行，建议不要写太长的行
%     columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加
%     basewidth       =   0.5em,
% }
\lstdefinestyle{SQL}{
    language        =   SQL, % 语言选C
    basicstyle      =   \zihao{-5}\ttfamily,
    numberstyle     =   \zihao{-5}\ttfamily,
    keywordstyle    =   \color{blue},
    keywordstyle    =   [2] \color{teal},
    stringstyle     =   \color{magenta},
    commentstyle    =   \color{red}\ttfamily,
    breaklines      =   true,   % 自动换行，建议不要写太长的行
    columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加
    basewidth       =   0.5em,
}


% 设置思源宋体为中文字体
\setCJKsansfont{Source Han Serif SC}

% 设置思源黑体为中文字体
\setCJKsansfont{Source Han Sans SC}

% 设置arev为英文字体
\setsansfont{Arev Sans}

% 字体颜色
\def\red{\color{red}}
\def\blue{\color{blue}}
\def\black{\color{black}}
\def\green{\color{green}}

\CTEXsetup[format={\Large\bfseries}]{section}

\definecolor{shadecolor}{RGB}{241, 241, 255}
\newcounter{problemname}
\newenvironment{problem}{\begin{shaded}\stepcounter{problemname}\par\noindent\textbf{题目\arabic{problemname}. }}{\end{shaded}\par}
\newenvironment{solution}{\par\noindent\textbf{解答. }}{\par}
\newenvironment{note}{\par\noindent\textbf{题目\arabic{problemname}的注记. }}{\par}
%\renewcommand{\proofname}{\bf 证明}

\begin{document}

\thispagestyle{empty}

\begin{figure}[t]
    \centering
    \includegraphics[width=13cm]{images/logo.png}
\end{figure}

\vspace*{\fill}
    \begin{center}
        \Huge\textbf{数据库原理}
    \end{center}
    \rightline{\LARGE\textbf{——课程作业}}
\vspace*{\fill}

\begin{table}[b]
    \centering
    \large
    \begin{tabular}{ll}
    \textbf{课程:} & 数据库原理 \\
    \textbf{班级:} & 1621402 \\
    \textbf{姓名:} & 黄钰轩 \\
    \textbf{学号:} & 162140222 \\
    \textbf{教师:} & 郑吉平 \\
    \textbf{学期:} & 2023-2024 春季 \\
    \end{tabular}
\end{table}

\newpage
\pagenumbering{Roman}
\setcounter{page}{1}
\tableofcontents
\newpage
\setcounter{page}{1}
\pagenumbering{arabic}

\section{第一章作业}

\begin{problem}
    试述数据、数据库、数据库管理系统、数据库系统的概念.
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 数据: 描述事物的符号记录.
        \begin{itemize}
            \item 在现实生活，数据是可识别的抽象符号，即描述事物的符号记录.
            \item 在计算机中，数据是所有能被计算机处理的符号的总称.
            \item 在数据库中，数据是数据库中存储的基本对象.
        \end{itemize}
        \item 数据库: 
        \begin{itemize}
            \item 一组相互有关联的数据集合.
            \item 长期储存在计算机中的有组织的、可管理和可共享的数据集合.
        \end{itemize}
        \item 数据库管理系统:
        \begin{itemize}
            \item 位于用户(应用程序)与操作系统之间的数据库管理软件.
            \item 一个管理数据的大型复杂基础软件系统.
        \end{itemize}
        \item 数据库系统: 
        \begin{itemize}
            \item 由数据库管理系统和相关工具组成的软件系统，用于管理和操作大量数据.
        \end{itemize}
    \end{enumerate}
\end{solution}

\begin{problem}
    试述数据模型的概念、作用及其包含的三个要素.
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 数据库模型的概念:
        \begin{itemize}
            \item 数据模型是数据库结构的基础，它是描述数据(数据结构)、数据之间的联系，数据语义即数据操作，以及一致性(完整性)约束的\textbf{概念和工具的集合}.
        \end{itemize}
        \item 数据库模型的作用:
        \begin{itemize}
            \item 在数据库领域，数据模型被广泛用于表示这些数据库设计的“描述”，更好的刻画数据.
            \item 数据模型精确描述了系统的静态特性、动态特性和完整性约束条件.
        \end{itemize}
        \item 数据库模型的三个要素:
        \begin{itemize}
            \item 数据结构: 数据结构描述数据库的组成对象以及对象之间的联系.
            \item 数据操纵: 是指对数据库中各种对象(型)的实例(值)允许进行的操作的集合，包括操作及有关的操作规则，是对系统动态特性的描述.
            \item 完整性约束: 是一组完整性规则的集合. 完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容.
        \end{itemize}
    \end{enumerate}
\end{solution}

\begin{problem}
    试述数据库系统的三级模式结构，并说明这种结构的优点是什么.
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 数据库系统的三级模式结构由模式、外模式和内模式组成.
        \begin{itemize}
            \item 模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图. 模式的一个具体值称为模式的一个实例.
            \item 外模式，亦称子模式或用户模式，是数据库用户(包括应用程序员和最终用户)能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示.
            \item 内模式也称物理模式或存储模式，它是对数据物理结构和存方式的描述，是数据在数据库内部的组织方式.
        \end{itemize}
        \item 三级模式结构的优点:
        \begin{itemize}
            \item 数据库系统的三级模式是对数据的三个抽象级别，它把数据的具体组织留给数据库管理系统，使用户能逻辑抽象地处理数据，而不必关心数据在计算机中的具体表示方式和存储方式.
            \item 数据库系统在这三级模式之间提供了两层映像: 外模式/模式映像和模式/内模式映像. 正是这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性.
        \end{itemize}
    \end{enumerate}
\end{solution}

\begin{problem}
    试述数据与程序的物理独立性和逻辑独立性. 为什么数据库系统具有较强的数据与程序的独立性?
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 
        \begin{itemize}
            \item 数据与程序的物理独立性: 当数据库的存储结构改变时(如选用了另一种存储结构)，由数据库管理员对模式/内模式映像做相应改变，可以使模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性，简称数据的物理独立性.
            \item 数据与程序的逻辑独立性: 当模式改变时(例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式/模式的映像做相应改变，可以使外模式保持不变. 应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性.
        \end{itemize}
        \item 数据库管理系统在三级模式之间提供的两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性.
    \end{enumerate}
\end{solution}

\newpage
\section{第二章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    试述关系模型的三个组成部分.
\end{problem}

\begin{solution}
    关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成.
    \begin{figure}[!htpb]
        \centering
        \includegraphics[width=15.5cm]{images/sec2/2-1_Relational_Model.pdf}
        \caption{关系模型框架}
        \label{fig2-1}
    \end{figure}
\end{solution}

\begin{problem} \label{2-6}
    设有一个$\mathbf{SPJ}$数据库，包括四个关系模式 $\mathbf{S}$、$\mathbf{P}$、$\mathbf{J}$ 和$\mathbf{SPJ}$.
    $$\begin{aligned}
        & \mathrm{S(SNO, SNAME, STATUS, CITY);}  \\
        & \mathrm{P(PNO, PNAME, COLOR, WEIGHT);} \\
        & \mathrm{J(JNO, JNAME, CITY);}          \\
        & \mathrm{SPJ(SNO, PNO, JNO, QTY)}.
    \end{aligned}$$

    供应商表$\mathbf{S}$由供应商代码(SNO)、供应商姓名(SNAME)、供应商状态(STATUS)、供应商所在城市(CITY)组成.

    零件表$\mathbf{P}$由零件代码(PNO)、零件名(PNAME)、颜色(COLOR)、重量(WEIGHT)组成.

    工程项目表$\mathbf{J}$由工程项目代码(JNO)、工程项目名(JNAME)、工程项目所在城市(CITY)组成.

    供应情况表$\mathbf{SPJ}$由供应商代码(SNO)、零件代码(PNO)、工程项目代码(JNO)、供应数量(QTY)组成，表示某供应商供应某种零件给某工程项目的数量为QTY.

    今有若干数据如 图 \ref{SPJ} 所示.

    试用关系代数、元组关系演算语言 ALPHA 完成如下查询:
    \begin{enumerate}[(1)]
        \item 求供应工程 J1 零件的供应商代码 SNO.
        \item 求供应工程 J1 零件 P1 的供应商代码 SNO.
        \item 求供应工程 J1 零件为红色的供应商代码 SNO.
        \item 求没有使用天津供应商生产的红色零件的工程号 JNO.
        \item 求至少使用了与供应商 S1 所供应的全部零件相同零件号的工程号 JNO.
    \end{enumerate}
\end{problem}

\begin{figure}[!htpb]
    \centering
    \includegraphics[width=13cm]{images/sec2/2-2_SPJ.pdf}
    \caption{SPJ 数据库数据}
    \label{SPJ}
\end{figure}

\begin{solution}
    \begin{enumerate}[(1)]
        \item
        \begin{itemize}
            \item 关系代数:
                  $$\Pi_{\mathrm{SNO}}(\sigma_{\mathrm{JNO} = '\mathrm{J1}'}(\mathbf{SPJ}))$$
            \item ALPHA语言:
                \lstinputlisting[
                    % style       =   C,
                    % caption     =   {\bf probe.c},
                    label       =   {3-1_code}
                ]{./code/sec2/3-1.txt}
        \end{itemize}
        \item
        \begin{itemize}
            \item 关系代数:
                  $$\Pi_{\mathrm{SNO}}(\sigma_{\mathrm{JNO} = '\mathrm{J1}' \land \mathrm{PNO} = '\mathrm{P1}'}(\mathbf{SPJ}))$$
            \item ALPHA语言:
                \lstinputlisting[
                    % style       =   C,
                    % caption     =   {\bf probe.c},
                    label       =   {3-2_code}
                ]{./code/sec2/3-2.txt}
        \end{itemize}
        \item
        \begin{itemize}
            \item 关系代数:
                  $$\Pi_{\mathrm{SNO}}(\Pi_{\mathrm{SNO}, \mathrm{PNO}}(\sigma_{\mathrm{JNO} = '\mathrm{J1}'}(\mathbf{SPJ})) \bowtie \Pi_{\mathrm{PNO}}(\sigma_{\mathrm{COLOR} = '\text{红}'}(\mathbf{P})))$$
            \item ALPHA语言:
                \lstinputlisting[
                        % style       =   C,
                        % caption     =   {\bf probe.c},
                        label       =   {3-3_code}
                    ]{./code/sec2/3-3.txt}
        \end{itemize}
        \item
        \begin{itemize}
            \item 关系代数:
            $$\Pi_{\mathrm{JNO}}(\mathbf{SPJ}) - \Pi_{\mathrm{JNO}}(\sigma_{\mathrm{CITY} = '\text{天津}' \land \mathrm{COLOR} = '\text{红}'}(\mathbf{S} \bowtie \mathbf{SPJ} \bowtie \mathbf{P}))$$
            \item ALPHA语言:
                \lstinputlisting[
                    % style       =   C,
                    % caption     =   {\bf probe.c},
                    label       =   {3-4_code}
                ]{./code/sec2/3-4.txt}
            \end{itemize}
        \item
        \begin{itemize}
            \item 关系代数:
                  $$\Pi_{\text{JNO},\text{PNO}}(\mathbf{SPJ}) \div \Pi_{\text{PNO}}(\sigma_{\text{SNO} = '\text{S1}'}(\mathbf{SPJ}))$$
            \item ALPHA语言:
                \lstinputlisting[
                    % style       =   C,
                    % caption     =   {\bf probe.c},
                    label       =   {3-5_code}
                ]{./code/sec2/3-5.txt}
        \end{itemize}
    \end{enumerate}
\end{solution}

\begin{problem}
    试述等值连接与自然连接的区别和联系.
\end{problem}

\begin{solution}
    \begin{itemize}
        \item 自然连接是一种特殊的等值连接.
        \item 自然连接将连接条件指定为$R$和$S$中属性名相同的列做等值连接，因此$p$可省略.
    \end{itemize}
\end{solution}
\newpage
\begin{note}
    以$\mathbf{Student}$、$\mathbf{SC}$表为例，
    $$\mathbf{Student}\bowtie_{\mathrm{Student.Sno = SC.Sno}}\mathbf{SC}$$
    结果如下:
    \begin{figure}[!htpb]
        \centering
        \includegraphics[width=15cm]{images/sec2/2-3_Equijoin.pdf}
        \caption{等值连接}
        \label{fig2-3_1}
    \end{figure}

    而
    $$\mathbf{Student}\bowtie\mathbf{SC}$$
    结果如下:
    \begin{figure}[!htpb]
        \centering
        \includegraphics[width=15cm]{images/sec2/2-3_Natural_Join.pdf}
        \caption{自然连接}
        \label{fig2-3_2}
    \end{figure}
\end{note}

\begin{problem}
    关系代数的基本运算有哪些? 如何用这些基本运算来表示其他运算?
\end{problem}

\begin{solution}
    \begin{itemize}
        \item 基本运算:
        \begin{itemize}
            \item 选择($\sigma$):
                  $$\sigma_p(R) = \{t | t \in R \land p(t) = True\}$$
            \item 投影($\Pi$):
                  $$\Pi_{A_1,A_2,\ldots,A_k}(R) = \{t[A_1,A_2,\ldots,A_k] | t \in R\}$$
            \item 并($\bigcup$):
                  $$R\bigcup S = \{t | t\in R \lor t \in S\}$$
            \item 差($-$):
                  $$R - S = \{t | t\in R \land t \notin S\}$$
            \item 笛卡尔积($\times$):
                  $$R \times S = \{(t, q) | t\in R \land q \in S\}$$
        \end{itemize}
        \item 附加运算:
        \begin{itemize}
            \item 交($\bigcap$):
                  $$R\bigcap S = \{t | t\in R \land t \in S\}$$
                  满足:
                  $$R\bigcap S = R - (R - S)$$
            \item 连接($\bowtie$):
                  $$R\bowtie_p S = \{(t, q) | t \in R \land q \in S \land p\left((t, q)\right) = True\}$$
                  满足:
                  $$R\bowtie_p S = \sigma_p(R \times S)$$
            \item 除($\div$): \\
                  设$R(A_1,A_2,\ldots,A_m, B_1,B_2,\ldots,B_n)$和$S(B_1,B_2,\ldots,B_n, C_1,C_2,\ldots,C_k)$ 是两个关系，则$R \div S$的属性为$A_1,A_2,\ldots,A_m$，且:
                  $$R \div S = \{t | t\in \Pi_{A_1,A_2,\ldots,A_m}(R) \land (\forall q \in \Pi_{B_1,B_2,\ldots,B_n}(S), (t, q) \in R)\}$$
                  满足:
                  $$R \div S = \Pi_{A_1,A_2,\ldots,A_m}(R) - \Pi_{A_1,A_2,\ldots,A_m}((\Pi_{A_1,A_2,\ldots,A_m}(R) \times \Pi_{B_1,B_2,\ldots,B_n}(S)) - R)$$
        \end{itemize}
    \end{itemize}
\end{solution}

\newpage
\section{第三章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    有两个关系 $\mathbf{S}(A, B, C, D)$ 和 $\mathbf{T}(C, D, E, F)$, 写出与下列查询等价的 SQL 表达式:
    \begin{enumerate}[(1)]
        \item $\sigma_{A = 10}(\mathbf{S})$.
        \item $\Pi_{A, B}(\mathbf{S})$.
        \item $\mathbf{S} \bowtie \mathbf{T}$.
        \item $\mathbf{S} \mathop{\bowtie}\limits_{\mathbf{S}.C = \mathbf{T}.C} \mathbf{T}$.
        \item $\mathbf{S} \mathop{\bowtie}\limits_{A < E} \mathbf{T}$.
        \item  $\Pi_{C, D}(\mathbf{S}) \times \mathbf{T}$.
    \end{enumerate}
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-1_code}
            ]{./code/sec3/3-1-1.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-2_code}
            ]{./code/sec3/3-1-2.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-3_code}
            ]{./code/sec3/3-1-3.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-4_code}
            ]{./code/sec3/3-1-4.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-5_code}
            ]{./code/sec3/3-1-5.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-6_code}
            ]{./code/sec3/3-1-6.sql}
    \end{enumerate}
\end{solution}

\begin{problem}
    使用 SQL 语句建立(\hyperref[2-6]{题目2-6})中 SPJ 数据库的四个表($\mathbf{S}$、$\mathbf{P}$、$\mathbf{J}$和$\mathbf{SPJ}$)，并针对建立的四个表用 SQL 语句完成(\hyperref[2-6]{题目2-6})中的查询.
\end{problem}

\begin{solution}
    \begin{itemize}
        \item 建表:
            \begin{itemize}
                \item 建 $\mathbf{S}$ 表:
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-1_code}
                    ]{./code/sec3/3-2-1.sql}
                \item 建 $\mathbf{P}$ 表:
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-2_code}
                    ]{./code/sec3/3-2-2.sql}
                \item 建 $\mathbf{J}$ 表:
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-3_code}
                    ]{./code/sec3/3-2-3.sql}
                \newpage
                \item 建 $\mathbf{SPJ}$ 表:
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-4_code}
                    ]{./code/sec3/3-2-4.sql}
            \end{itemize}
        \item 查询:
            \begin{enumerate}[(1)]
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-5_code}
                    ]{./code/sec3/3-2-5.sql}
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-6_code}
                    ]{./code/sec3/3-2-6.sql}
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-7_code}
                    ]{./code/sec3/3-2-7.sql}
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-8_code}
                    ]{./code/sec3/3-2-8.sql}
                \newpage
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-9_code}
                    ]{./code/sec3/3-2-9.sql}
            \end{enumerate}
    \end{itemize}
\end{solution}

\begin{problem}
    针对(\hyperref[2-6]{题目2-6})中的四个表($\mathbf{S}$、$\mathbf{P}$、$\mathbf{J}$和$\mathbf{SPJ}$)，试用 SQL 完成以下各项操作:
    \begin{enumerate}[(1)]
        \item 找出所有供应商的姓名和所在城市.
        \item 找出所有零件的名称、颜色、重量.
        \item 找出使用供应商 S1 所供应零件的工程代码.
        \item 找出工程项目 J2 使用的各种零件的名称及其数量.
        \item 找出上海厂商供应的所有零件代码.
        \item 找出使用上海产的零件的工程名称.
        \item 找出没有使用天津产的零件的工程代码.
        \item 把全部红色零件的颜色改成蓝色.
        \item 把由 S5 供给 J2 的零件 P6 改为由 S3 供应.
        \item 从供应商关系中删除 S2 的记录，并从供应情况关系中删除相应的记录.
        \item 请将 (S2, J6, P4, 200) 插入供应情况关系.
    \end{enumerate}
\end{problem}

\newpage
\begin{solution}
    \begin{enumerate}[(1)]
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-1_code}
            ]{./code/sec3/3-3-1.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-2_code}
            ]{./code/sec3/3-3-2.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-3_code}
            ]{./code/sec3/3-3-3.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-4_code}
            ]{./code/sec3/3-3-4.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-5_code}
            ]{./code/sec3/3-3-5.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-6_code}
            ]{./code/sec3/3-3-6.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-7_code}
            ]{./code/sec3/3-3-7.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-8_code}
            ]{./code/sec3/3-3-8.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-9_code}
            ]{./code/sec3/3-3-9.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-10_code}
            ]{./code/sec3/3-3-10.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-11_code}
            ]{./code/sec3/3-3-11.sql}
        
    \end{enumerate}
\end{solution}

\newpage
\begin{problem}
    针对(\hyperref[2-6]{题目2-6})中的四个表($\mathbf{S}$、$\mathbf{P}$、$\mathbf{J}$和$\mathbf{SPJ}$)，为三建工程项目建立一个供应情况的视图，包括供应商代码(SNO)、零件代码(PNO)、供应数量(QTY). 针对该视图完成下列查询:
    \begin{enumerate}[(1)]
        \item 找出三建工程项目使用的各种零件代码及其数量.
        \item 找出供应商 S1 供应三建工程情况.
    \end{enumerate}
\end{problem}

\begin{solution}
    \begin{itemize}
        \item 创建视图:
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-4-1_code}
            ]{./code/sec3/3-4-1.sql}
        \item 查询
            \begin{enumerate}[(1)]
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-4-2_code}
                    ]{./code/sec3/3-4-2.sql}
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-4-3_code}
                    ]{./code/sec3/3-4-3.sql}
            \end{enumerate}
    \end{itemize}
\end{solution}

\newpage
\section{第四章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    今有以下两个关系模式:
    $$\begin{aligned}
        & \text{\textbf{职工}(职工号, 姓名, 年龄, 职务, 工资, 部门号)};  \\
        & \text{\textbf{部门}(部门号, 名称, 经理名, 地址, 电话号)}. \\
    \end{aligned}$$
    请用 SQL 的 GRANT 语句和 REVOKE 语句(加上视图机制)实现以下授权定义和存取控制的功能:
    \begin{enumerate}[(1)]
        \item 用户王明对两个表有 SELECT 权限.
        \item 用户李勇对两个表有 INSERT 和 DELETE 权限.
        \item 每个职工只对自己的记录有 SELECT 权限.
        \item 用户刘星对职工表有 SELECT 权限，对``工资"字段具有更新权限.
        \item 用户张新具有修改这两个表的结构的权限.
        \item 用户周平具有对两个表的所有权限，并具有给其他用户授权的权限.
        \item 用户杨兰具有从每个部门职工中 SELECT 最高工资、最低工资、平均工资的权限，但不能查看每个人的工资.
    \end{enumerate}
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item \  
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-1_code}
            ]{./code/sec4/4-1-1.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-2_code}
            ]{./code/sec4/4-1-2.sql}
        \item \  
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-3_code}
            ]{./code/sec4/4-1-3.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-4_code}
            ]{./code/sec4/4-1-4.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-5_code}
            ]{./code/sec4/4-1-5.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-6_code}
            ]{./code/sec4/4-1-6.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-7_code}
            ]{./code/sec4/4-1-7.sql}
    \end{enumerate}
\end{solution}

\newpage
\section{第五章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    假设有下面两个关系模式:
    $$\begin{aligned}
        & \text{\textbf{职工}(职工号, 姓名, 出生日期, 职务, 工资, 部门号), 其中职工号为主码};  \\
        & \text{\textbf{部门}(部门号, 名称, 经理姓名, 电话), 其中部门号为主码}. \\
    \end{aligned}$$
    用 SQL 定义这两个关系模式，要求在模式中完成以下完整性约束的定义:
    \begin{enumerate}[(1)]
        \item 定义每个模式的主码.
        \item 定义参照完整性约束.
        \item 定义职工年龄不超过 65 岁.
    \end{enumerate}
\end{problem}

\begin{solution}
    \lstinputlisting[
        style       =   SQL,
        % caption     =   {\bf probe.c},
        label       =   {5-1-1_code}
    ]{./code/sec5/5-1-1.sql}
\end{solution}


\newpage
\section{第六章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    设有关系模式$R<U, F>$, 其中$U = \{ A, B, C, D, E \}, F = \{ A \rightarrow B, BC \rightarrow E, ED \rightarrow AB \}$.
    \begin{enumerate}[(1)]
        \item 计算$A_F^+$、$(AB)_F^+$、$(ABC)_F^+$、$(BCD)_F^+$.
        \item 求$R$的所有候选码，并说明理由.
        \item $R$最高满足第几范式？为什么？
    \end{enumerate}
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 
            \begin{itemize}
                \item $A_F^+$
                \begin{enumerate}[$1^\circ$]
                    \item 令$A^{(0)} = A$
                    \item 在$F$中找到左边是$A$子集的函数依赖，有$A \rightarrow B$, \\
                    则$A^{(1)} = A^{(0)}\bigcup B = AB$
                    \item 虽然$A^{(1)} \not= A^{(0)}$，但是$F$中未用过的函数依赖的左边属性集中已经没有$A^{(1)}$自己了，因此可以退出循环
                    \item 输出$A_F^+ = AB$
                \end{enumerate}
                \item $(AB)_F^+$
                \begin{enumerate}[$1^\circ$]
                    \item 令$(AB)^{(0)} = AB$
                    \item 在$F$中找到左边是$AB$子集的函数依赖，有$A \rightarrow B$, \\
                    则$(AB)^{(1)} = (AB)^{(0)}\bigcup B = AB$
                    \item $(AB)^{(1)} = (AB)^{(0)}$，退出循环
                    \item 输出$(AB)_F^+ = AB$
                \end{enumerate}
                \item $(ABC)_F^+$
                \begin{enumerate}[$1^\circ$]
                    \item 令$(ABC)^{(0)} = ABC$
                    \item 在$F$中找到左边是$ABC$子集的函数依赖，有$A \rightarrow B, BC \rightarrow E$, \\
                    则$(ABC)^{(1)} = (ABC)^{(0)}\bigcup BE = ABCE$
                    \item 虽然$(ABC)^{(1)} \not= (ABC)^{(0)}$，但是$F$中未用过的函数依赖的左边属性集中已经没有$(ABC)^{(1)}$自己了，因此可以退出循环
                    \item 输出$(ABC)_F^+ = ABCE$
                \end{enumerate}
                \newpage
                \item $(BCD)_F^+$
                \begin{enumerate}[$1^\circ$]
                    \item 令$(BCD)^{(0)} = BCD$
                    \item 在$F$中找到左边是$BCD$子集的函数依赖，有$BC \rightarrow E$, \\
                    则$(BCD)^{(1)} = (BCD)^{(0)}\bigcup E = BCDE$
                    \item 在$F$中找到左边是$BCDE$子集的函数依赖，有$ED \rightarrow AB$, \\
                    则$(BCD)^{(2)} = (BCD)^{(1)}\bigcup AB = ABCDE$
                    \item $(BCD)^{(2)} = U$，\\
                    则$(BCD)^{(2)}$就是$(BCD)_F^+$
                    \item 输出$(BCD)_F^+ = ABCDE$
                \end{enumerate}
            \end{itemize}
        \item 
            \begin{enumerate}[$1^\circ$]
                \item 计算$L$类、$N$类、$LR$类属性. $L$类属性有$CD$, $N$类属性为空，\\
                $LR$类属性有$ABE$. 令$X$为$L$类属性的集合，$Y$为$LR$类属性的集合
                \item 计算属性集$X$关于$U$上的函数依赖集$F$的闭包$X_F^+$，有$X_F^+ = CD \not= U$
                \item 遍历$Y$中的单一属性，并与$X$构成属性组，后计算闭包. 有:
                    \begin{itemize}
                        \item $(XA)_F^+ = (ACD)_F^+ = ABCDE$，因此$ACD$是候选码
                        \item $(XB)_F^+ = (BCD)_F^+ = ABCDE$，因此$BCD$是候选码
                        \item $(XE)_F^+ = (CDE)_F^+ = ABCDE$，因此$CDE$是候选码
                    \end{itemize}
            \end{enumerate}
            综上，关系模式$R<U, F>$的所有候选码为$ACD$、$BCD$、$CDE$.
        \item 
            \begin{enumerate}[$1^\circ$]
                \item 由于$BCD\rightarrow E, BC\rightarrow E$, 存在非主属性对码的部分函数依赖，所以$R$不满足 2NF.
            \end{enumerate}

            综上，$R$最高满足 1NF.
        \end{enumerate}
\end{solution}

\begin{problem}
    设有关系模式$R<U, F>$, 其中$U = \{ A, B, C, D, E, F \}$, \\$F = \{ A \rightarrow BC, CD \rightarrow E, B \rightarrow D, E \rightarrow A, CD \rightarrow A, A \rightarrow D \}$. 求: 
    \begin{enumerate}[(1)]
        \item 最小依赖集.
        \item 所有的候选码.
    \end{enumerate}
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 
            \begin{enumerate}[$1^\circ$]
                \item $F = \{ A \rightarrow B, A \rightarrow C, CD \rightarrow E, B \rightarrow D, E \rightarrow A, CD \rightarrow A, A \rightarrow D \}$
                \item 
                    \begin{itemize}
                        \item 考察$A \rightarrow B, G = \{ A \rightarrow C, CD \rightarrow E, B \rightarrow D, E \rightarrow A, CD \rightarrow A, A \rightarrow D \},$ \\
                            $A_G^+ = ACDE, A \rightarrow B$ 保留
                        \item 考察$A \rightarrow C, G = \{ A \rightarrow B, CD \rightarrow E, B \rightarrow D, E \rightarrow A, CD \rightarrow A, A \rightarrow D \},$ \\
                        $A_G^+ = ABD, A \rightarrow C$ 保留
                        \item 考察$CD \rightarrow E, G = \{ A \rightarrow B, A \rightarrow C, B \rightarrow D, E \rightarrow A, CD \rightarrow A, A \rightarrow D \},$ \\
                        $(CD)_G^+ = ABCD, CD \rightarrow E$ 保留
                        \item 考察$B \rightarrow D, G = \{ A \rightarrow B, A \rightarrow C, CD \rightarrow E, E \rightarrow A, CD \rightarrow A, A \rightarrow D \},$ \\
                        $B_G^+ = B, B \rightarrow D$ 保留
                        \item 考察$E \rightarrow A, G = \{ A \rightarrow B, A \rightarrow C, CD \rightarrow E, B \rightarrow D, CD \rightarrow A, A \rightarrow D \},$ \\
                        $E_G^+ = E, E \rightarrow A$ 保留
                        \item 考察$CD \rightarrow A, G = \{ A \rightarrow B, A \rightarrow C, CD \rightarrow E, B \rightarrow D, E \rightarrow A, A \rightarrow D \},$ \\
                        $(CD)_G^+ = ABCDE, CD \rightarrow A$ 是多余的
                        \item 考察$A \rightarrow D, G = \{ A \rightarrow B, A \rightarrow C, CD \rightarrow E, B \rightarrow D, E \rightarrow A \},$ \\
                        $A_G^+ = ABCDE, A \rightarrow D$ 是多余的
                    \end{itemize}
                    于是$H = \{ A \rightarrow B, A \rightarrow C, CD \rightarrow E, B \rightarrow D, E \rightarrow A \}$
                \item 考察左部多余的属性
                    \begin{itemize}
                        \item 考察$CD \rightarrow E$
                            \begin{itemize}
                                \item $C_H^+ = C$, 不包含$E$, $C$ 保留
                                \item $D_H^+ = D$, 不包含$E$, $D$ 保留
                            \end{itemize}
                    \end{itemize}
            \end{enumerate}
            于是$$F_{min} = \{ A \rightarrow B, A \rightarrow C, CD \rightarrow E, B \rightarrow D, E \rightarrow A \}$$
        \item $F = \{ A \rightarrow B, A \rightarrow C, CD \rightarrow E, B \rightarrow D, E \rightarrow A \}$
            \begin{enumerate}[$1^\circ$]
                \item 计算$L$类、$N$类、$LR$类属性. $L$类属性有$B$, $N$类属性为空，\\
                $LR$类属性有$ACDE$. 令$X$为$L$类属性的集合，$Y$为$LR$类属性的集合
                \item 计算属性集$X$关于$U$上的函数依赖集$F$的闭包$X_F^+$，有$X_F^+ = BD \not= U$
                \item 遍历$Y$中的单一属性，并与$X$构成属性组，后计算闭包. 有:
                    \begin{itemize}
                        \item $(XA)_F^+ = (AB)_F^+ = ABCDE$，因此$AB$是候选码
                        \item $(XC)_F^+ = (BC)_F^+ = BC \not= U$，因此$BC$不是候选码
                        \item $(XD)_F^+ = (BD)_F^+ = BD \not= U$，因此$BD$不是候选码
                        \item $(XE)_F^+ = (BE)_F^+ = ABCDE$，因此$BE$是候选码
                    \end{itemize}
                \item 此时 $Y = \{ C, D \}$, 遍历$Y$中的任意两个属性，并与$X$构成属性组，后计算闭包. 有:
                    \begin{itemize}
                        \item $Z = CD, (XZ)_F^+ = (BCD)_F^+ = ABCDE$，因此$BCD$是候选码
                    \end{itemize}
            \end{enumerate}
            综上，关系模式$R<U, F>$的所有候选码为$AB$、$BE$、$BCD$.
    \end{enumerate}
\end{solution}

\begin{problem}
    给定关系$Q(A, B, C, D, E)$如\hyperref[Q]{表 1 }所示，试给出至少2个非对称多值依赖.
\end{problem}

\begin{longtable}{|c|c|c|c|c|}
    \hline
    \bf A & \bf B & \bf C & \bf D & \bf E \\
    \hline
    $a$ & $b$ & $c$ & $d$ & $e$ \\
    \hline
    $a$ & $b'$ & $c'$ & $d'$ & $e'$ \\
    \hline
    $a$ & $b$ & $c$ & $d'$ & $e'$ \\
    \hline
    $a$ & $b'$ & $c'$ & $d$ & $e$ \\
    \hline
    $a$ & $b$ & $c$ & $d$ & $e'$ \\
    \hline
    $a$ & $b$ & $c$ & $d'$ & $e$ \\
    \hline
    $a$ & $b'$ & $c'$ & $d'$ & $e$ \\
    \hline
    $a$ & $b'$ & $c'$ & $d$ & $e'$ \\
    \hline
    \caption{关系$Q$}
    \label{Q}
\end{longtable}

\begin{solution}
    \begin{itemize}
        \item 
            令$$X = \{ A, B \}, Y = \{ C \},$$
            于是$$Z = U - X - Y = \{ D, E \}.$$
            对于任意一对$(x, z)$, $y$的值仅由$x$决定而与$z$无关，
            于是存在多值依赖$$X\rightarrow\rightarrow Y,$$
            此时$X\rightarrow\rightarrow Z$并不成立, 所以$X\rightarrow\rightarrow Y$是一个非对称多值依赖.
        \item 
            令$$X = \{ A, C \}, Y = \{ B \},$$
            于是$$Z = U - X - Y = \{ D, E \}.$$
            对于任意一对$(x, z)$, $y$的值仅由$x$决定而与$z$无关，
            于是存在多值依赖$$X\rightarrow\rightarrow Y,$$
            此时$X\rightarrow\rightarrow Z$并不成立, 所以$X\rightarrow\rightarrow Y$是一个非对称多值依赖.
    \end{itemize}
\end{solution}

\begin{problem}
    试由 Armstrong 公理系统推导出下面的推理规则:
    
    若$A \rightarrow B, BC \rightarrow D$, 则有 $AC \rightarrow D$.
\end{problem}

\begin{solution}
    \begin{enumerate}[$1^\circ$]
        \item 由题中给出$A \rightarrow B$成立，\\根据增广律，可以推出$AC\rightarrow BC$成立.
        \item 由题中给出$BC \rightarrow D$成立，\\根据传递律，可以推出$AC\rightarrow D$成立，\\题目得证.
    \end{enumerate}
\end{solution}

\begin{note}
    本题事实上完成了\textbf{伪传递规则}的推导.
\end{note}

\begin{problem}
    设有如\hyperref[S]{表 2 }所示的学生关系$S$.
    \begin{enumerate}[(1)]
        \item 试问$S$是否属于 3NF, 请做出判断并给出理由.
        \item 若不是 3NF, 它属于第几范式.
        \item 若不是 3NF, 请将其规范化为 3NF.
    \end{enumerate}
\end{problem}

\begin{longtable}{|c|c|c|c|c|c|}
    \hline
    \bf 学号 & \bf 学生名 & \bf 年龄 & \bf 性别 & \bf 系号 & \bf 系名 \\
    \hline
    10001 & 王婧 & 18 & 女 & 1 & 通信工程 \\
    20001 & 张露 & 19 & 女 & 2 & 电子工程 \\
    20002 & 黎明远 & 20 & 男 & 2 & 电子工程 \\
    30001 & 王烨 & 21 & 男 & 3 & 计算机 \\
    30004 & 张露 & 20 & 女 & 3 & 计算机 \\
    30005 & 潘建 & 19 & 男 & 3 & 计算机 \\
    \hline
    \caption{关系$S$}
    \label{S}
\end{longtable}

\begin{solution}
    令$\text{学号} = A, \text{学生名} = B, \text{年龄} = C, \text{性别} = D, \text{系号} = E, \text{系名} = F,$
    则有关系模式$S<U,F>$, 其中
    $$
        \begin{aligned}
            & U = \{A, B, C, D, E, F\} \\
            & \begin{aligned}
                F = \{ &A\rightarrow B, \\
                & A\rightarrow C, \\
                & A\rightarrow D, \\
                & A\rightarrow E, \\
                & A\rightarrow F, \\
                & E\rightarrow F\}
              \end{aligned}
        \end{aligned}
    $$
    接下来求解$S$的所有候选码:
    \begin{enumerate}[$1^\circ$]
        \item 计算$L$类、$N$类、$LR$类属性. $L$类属性有$A$, $N$类属性为空，\\
        $LR$类属性有$E$. 令$X$为$L$类属性的集合，$Y$为$LR$类属性的集合
        \item 计算属性集$X$关于$U$上的函数依赖集$F$的闭包$X_F^+$，有$X_F^+ = ABCDE = U$
        \item 因为$X = \{ A \}$, 因此$A$是唯一候选码
    \end{enumerate}
    综上，关系模式$S<U, F>$的所有候选码为$A$.
    \begin{enumerate}[(1)]
        \item 
            有$$A\rightarrow E, E\rightarrow F,$$
            且$$E\not\rightarrow A.$$
            存在主属性对码的传递函数依赖，所以$S$不属于3NF.
        \item 
            \begin{enumerate}[$1^\circ$]
                \item 不存在主属性对码的部分函数依赖，所以$S$最低满足2NF.
                \item 存在主属性对码的传递函数依赖，所以$S$不满足3NF.
            \end{enumerate}
            综上，$S$ 最高满足 2NF.
        \item 
            可以将关系模式$S<U, F>$拆分为$S_1<U_1, F_1>$、$S_2<U_2, F_2>$与$S_3<U_3, F_3>$, 其中
            $$
                \begin{aligned}
                    & U_1 = \{A, B, C, D\} \\
                    & \begin{aligned}
                        F_1 = \{ &A\rightarrow B, \\
                        & A\rightarrow C, \\
                        & A\rightarrow D\}
                    \end{aligned} \\
                    & U_2 = \{A, E\} \\
                    & F_2 = \{A \rightarrow E\} \\
                    & U_3 = \{E, F\} \\
                    & F_3 = \{E \rightarrow F\} \\
                \end{aligned}
            $$
            这样，便消除了主属性对码的部分和传递函数依赖.
    \end{enumerate}
\end{solution}


% \newpage
% \section{第x章作业}
% % 计数器置零
% \setcounter{problemname}{0}

% \begin{problem}

% \end{problem}

% \begin{solution}

% \end{solution}

\end{document}