% \documentclass[12pt, a4paper, oneside]{ctexart}
\documentclass[12pt, oneside]{ctexart}
\usepackage{amsmath, amsthm, amssymb, bm, color, enumerate, framed, graphicx, longtable, mathrsfs, subfigure, tikz, ulem}
% \usepackage[dvipsnames]{xcolor}
% \usepackage{geometry}
\usepackage[a4paper, total={145mm,210mm}]{geometry}
\geometry{left=2.54cm,right=2.54cm,top=3.18cm,bottom=3.18cm}
\usepackage{pdfpages}

%按章节编号
\numberwithin{figure}{section}
\numberwithin{table}{section}

% 超链接设置
\usepackage{hyperref}
\hypersetup{  
    colorlinks = true,    % 更改链接颜色  
    linkcolor = black,      % 链接颜色  
    urlcolor = blue,        % URL 颜色  
    citecolor = green,     % 引用颜色  
    % underline = true,  
    linkbordercolor = red,
}
% \hypersetup{colorlinks=true,linkcolor=black}


%代码包设置
\usepackage{listings}
\lstset{
    basicstyle          =   \sffamily,          % 基本代码风格
    keywordstyle        =   \bfseries,          % 关键字风格
    commentstyle        =   \rmfamily\itshape,  % 注释的风格，斜体
    stringstyle         =   \ttfamily,  % 字符串风格
    flexiblecolumns,                % 别问为什么，加上这个
    numbers             =   left,   % 行号的位置在左边
    showspaces          =   false,  % 是否显示空格，显示了有点乱，所以不现实了
    numberstyle         =   \zihao{-5}\ttfamily,    % 行号的样式，小五号，tt等宽字体
    showstringspaces    =   false,
    captionpos          =   t,      % 这段代码的名字所呈现的位置，t指的是top上面
    frame               =   lrtb,   % 显示边框
}
% \lstdefinestyle{C}{
%     language        =   C, % 语言选C
%     basicstyle      =   \zihao{-5}\ttfamily,
%     numberstyle     =   \zihao{-5}\ttfamily,
%     keywordstyle    =   \color{blue},
%     keywordstyle    =   [2] \color{teal},
%     stringstyle     =   \color{magenta},
%     commentstyle    =   \color{red}\ttfamily,
%     breaklines      =   true,   % 自动换行，建议不要写太长的行
%     columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加
%     basewidth       =   0.5em,
% }
\lstdefinestyle{SQL}{
    language        =   SQL, % 语言选C
    basicstyle      =   \zihao{-5}\ttfamily,
    numberstyle     =   \zihao{-5}\ttfamily,
    keywordstyle    =   \color{blue},
    keywordstyle    =   [2] \color{teal},
    stringstyle     =   \color{magenta},
    commentstyle    =   \color{red}\ttfamily,
    breaklines      =   true,   % 自动换行，建议不要写太长的行
    columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加
    basewidth       =   0.5em,
}


% 设置思源宋体为中文字体
\setCJKsansfont{Source Han Serif SC}

% 设置思源黑体为中文字体
\setCJKsansfont{Source Han Sans SC}

% 设置arev为英文字体
\setsansfont{Arev Sans}

% 字体颜色
\def\red{\color{red}}
\def\blue{\color{blue}}
\def\black{\color{black}}
\def\green{\color{green}}

\CTEXsetup[format={\Large\bfseries}]{section}

\definecolor{shadecolor}{RGB}{241, 241, 255}
\newcounter{problemname}
\newenvironment{problem}{\begin{shaded}\stepcounter{problemname}\par\noindent\textbf{题目\arabic{problemname}. }}{\end{shaded}\par}
\newenvironment{solution}{\par\noindent\textbf{解答. }}{\par}
\newenvironment{note}{\par\noindent\textbf{题目\arabic{problemname}的注记. }}{\par}
%\renewcommand{\proofname}{\bf 证明}

\begin{document}

\thispagestyle{empty}

\begin{figure}[t]
    \centering
    \includegraphics[width=13cm]{images/logo.png}
\end{figure}

\vspace*{\fill}
    \begin{center}
        \Huge\textbf{数据库原理}
    \end{center}
    \rightline{\LARGE\textbf{——课程作业}}
\vspace*{\fill}

\begin{table}[b]
    \centering
    \large
    \begin{tabular}{ll}
    \textbf{课程:} & 数据库原理 \\
    \textbf{班级:} & 1621402 \\
    \textbf{姓名:} & 黄钰轩 \\
    \textbf{学号:} & 162140222 \\
    \textbf{教师:} & 郑吉平 \\
    \textbf{学期:} & 2023-2024 春季 \\
    \end{tabular}
\end{table}

\newpage
\pagenumbering{Roman}
\setcounter{page}{1}
\tableofcontents
\newpage
\setcounter{page}{1}
\pagenumbering{arabic}

\section{第一章作业}

\begin{problem}
    试述数据、数据库、数据库管理系统、数据库系统的概念.
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 数据: 描述事物的符号记录.
        \begin{itemize}
            \item 在现实生活，数据是可识别的抽象符号，即描述事物的符号记录.
            \item 在计算机中，数据是所有能被计算机处理的符号的总称.
            \item 在数据库中，数据是数据库中存储的基本对象.
        \end{itemize}
        \item 数据库: 
        \begin{itemize}
            \item 一组相互有关联的数据集合.
            \item 长期储存在计算机中的有组织的、可管理和可共享的数据集合.
        \end{itemize}
        \item 数据库管理系统:
        \begin{itemize}
            \item 位于用户(应用程序)与操作系统之间的数据库管理软件.
            \item 一个管理数据的大型复杂基础软件系统.
        \end{itemize}
        \item 数据库系统: 
        \begin{itemize}
            \item 由数据库管理系统和相关工具组成的软件系统，用于管理和操作大量数据.
        \end{itemize}
    \end{enumerate}
\end{solution}

\begin{problem}
    试述数据模型的概念、作用及其包含的三个要素.
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 数据库模型的概念:
        \begin{itemize}
            \item 数据模型是数据库结构的基础，它是描述数据(数据结构)、数据之间的联系，数据语义即数据操作，以及一致性(完整性)约束的\textbf{概念和工具的集合}.
        \end{itemize}
        \item 数据库模型的作用:
        \begin{itemize}
            \item 在数据库领域，数据模型被广泛用于表示这些数据库设计的“描述”，更好的刻画数据.
            \item 数据模型精确描述了系统的静态特性、动态特性和完整性约束条件.
        \end{itemize}
        \item 数据库模型的三个要素:
        \begin{itemize}
            \item 数据结构: 数据结构描述数据库的组成对象以及对象之间的联系.
            \item 数据操纵: 是指对数据库中各种对象(型)的实例(值)允许进行的操作的集合，包括操作及有关的操作规则，是对系统动态特性的描述.
            \item 完整性约束: 是一组完整性规则的集合. 完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容.
        \end{itemize}
    \end{enumerate}
\end{solution}

\begin{problem}
    试述数据库系统的三级模式结构，并说明这种结构的优点是什么.
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 数据库系统的三级模式结构由模式、外模式和内模式组成.
        \begin{itemize}
            \item 模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图. 模式的一个具体值称为模式的一个实例.
            \item 外模式，亦称子模式或用户模式，是数据库用户(包括应用程序员和最终用户)能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示.
            \item 内模式也称物理模式或存储模式，它是对数据物理结构和存方式的描述，是数据在数据库内部的组织方式.
        \end{itemize}
        \item 三级模式结构的优点:
        \begin{itemize}
            \item 数据库系统的三级模式是对数据的三个抽象级别，它把数据的具体组织留给数据库管理系统，使用户能逻辑抽象地处理数据，而不必关心数据在计算机中的具体表示方式和存储方式.
            \item 数据库系统在这三级模式之间提供了两层映像: 外模式/模式映像和模式/内模式映像. 正是这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性.
        \end{itemize}
    \end{enumerate}
\end{solution}

\begin{problem}
    试述数据与程序的物理独立性和逻辑独立性. 为什么数据库系统具有较强的数据与程序的独立性?
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 
        \begin{itemize}
            \item 数据与程序的物理独立性: 当数据库的存储结构改变时(如选用了另一种存储结构)，由数据库管理员对模式/内模式映像做相应改变，可以使模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性，简称数据的物理独立性.
            \item 数据与程序的逻辑独立性: 当模式改变时(例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式/模式的映像做相应改变，可以使外模式保持不变. 应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性.
        \end{itemize}
        \item 数据库管理系统在三级模式之间提供的两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性.
    \end{enumerate}
\end{solution}

\newpage
\section{第二章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    试述关系模型的三个组成部分.
\end{problem}

\begin{solution}
    关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成.
    \begin{figure}[!htpb]
        \centering
        \includegraphics[width=15.5cm]{images/sec2/2-1_Relational_Model.pdf}
        \caption{关系模型框架}
        \label{fig2-1}
    \end{figure}
\end{solution}

\begin{problem} \label{2-6}
    设有一个$\mathbf{SPJ}$数据库，包括四个关系模式 $\mathbf{S}$、$\mathbf{P}$、$\mathbf{J}$ 和$\mathbf{SPJ}$.
    $$\begin{aligned}
        & \mathrm{S(SNO, SNAME, STATUS, CITY);}  \\
        & \mathrm{P(PNO, PNAME, COLOR, WEIGHT);} \\
        & \mathrm{J(JNO, JNAME, CITY);}          \\
        & \mathrm{SPJ(SNO, PNO, JNO, QTY)}.
    \end{aligned}$$

    供应商表$\mathbf{S}$由供应商代码(SNO)、供应商姓名(SNAME)、供应商状态(STATUS)、供应商所在城市(CITY)组成.

    零件表$\mathbf{P}$由零件代码(PNO)、零件名(PNAME)、颜色(COLOR)、重量(WEIGHT)组成.

    工程项目表$\mathbf{J}$由工程项目代码(JNO)、工程项目名(JNAME)、工程项目所在城市(CITY)组成.

    供应情况表$\mathbf{SPJ}$由供应商代码(SNO)、零件代码(PNO)、工程项目代码(JNO)、供应数量(QTY)组成，表示某供应商供应某种零件给某工程项目的数量为QTY.

    今有若干数据如 图 \ref{SPJ} 所示.

    试用关系代数、元组关系演算语言 ALPHA 完成如下查询:
    \begin{enumerate}[(1)]
        \item 求供应工程 J1 零件的供应商代码 SNO.
        \item 求供应工程 J1 零件 P1 的供应商代码 SNO.
        \item 求供应工程 J1 零件为红色的供应商代码 SNO.
        \item 求没有使用天津供应商生产的红色零件的工程号 JNO.
        \item 求至少使用了与供应商 S1 所供应的全部零件相同零件号的工程号 JNO.
    \end{enumerate}
\end{problem}

\begin{figure}[!htpb]
    \centering
    \includegraphics[width=13cm]{images/sec2/2-2_SPJ.pdf}
    \caption{SPJ 数据库数据}
    \label{SPJ}
\end{figure}

\begin{solution}
    \begin{enumerate}[(1)]
        \item
        \begin{itemize}
            \item 关系代数:
                  $$\Pi_{\mathrm{SNO}}(\sigma_{\mathrm{JNO} = '\mathrm{J1}'}(\mathbf{SPJ}))$$
            \item ALPHA语言:
                \lstinputlisting[
                    % style       =   C,
                    % caption     =   {\bf probe.c},
                    label       =   {3-1_code}
                ]{./code/sec2/3-1.txt}
        \end{itemize}
        \item
        \begin{itemize}
            \item 关系代数:
                  $$\Pi_{\mathrm{SNO}}(\sigma_{\mathrm{JNO} = '\mathrm{J1}' \land \mathrm{PNO} = '\mathrm{P1}'}(\mathbf{SPJ}))$$
            \item ALPHA语言:
                \lstinputlisting[
                    % style       =   C,
                    % caption     =   {\bf probe.c},
                    label       =   {3-2_code}
                ]{./code/sec2/3-2.txt}
        \end{itemize}
        \item
        \begin{itemize}
            \item 关系代数:
                  $$\Pi_{\mathrm{SNO}}(\Pi_{\mathrm{SNO}, \mathrm{PNO}}(\sigma_{\mathrm{JNO} = '\mathrm{J1}'}(\mathbf{SPJ})) \bowtie \Pi_{\mathrm{PNO}}(\sigma_{\mathrm{COLOR} = '\text{红}'}(\mathbf{P})))$$
            \item ALPHA语言:
                \lstinputlisting[
                        % style       =   C,
                        % caption     =   {\bf probe.c},
                        label       =   {3-3_code}
                    ]{./code/sec2/3-3.txt}
        \end{itemize}
        \item
        \begin{itemize}
            \item 关系代数:
            $$\Pi_{\mathrm{JNO}}(\mathbf{SPJ}) - \Pi_{\mathrm{JNO}}(\sigma_{\mathrm{CITY} = '\text{天津}' \land \mathrm{COLOR} = '\text{红}'}(\mathbf{S} \bowtie \mathbf{SPJ} \bowtie \mathbf{P}))$$
            \item ALPHA语言:
                \lstinputlisting[
                    % style       =   C,
                    % caption     =   {\bf probe.c},
                    label       =   {3-4_code}
                ]{./code/sec2/3-4.txt}
            \end{itemize}
        \item
        \begin{itemize}
            \item 关系代数:
                  $$\Pi_{\text{JNO},\text{PNO}}(\mathbf{SPJ}) \div \Pi_{\text{PNO}}(\sigma_{\text{SNO} = '\text{S1}'}(\mathbf{SPJ}))$$
            \item ALPHA语言:
                \lstinputlisting[
                    % style       =   C,
                    % caption     =   {\bf probe.c},
                    label       =   {3-5_code}
                ]{./code/sec2/3-5.txt}
        \end{itemize}
    \end{enumerate}
\end{solution}

\begin{problem}
    试述等值连接与自然连接的区别和联系.
\end{problem}

\begin{solution}
    \begin{itemize}
        \item 自然连接是一种特殊的等值连接.
        \item 自然连接将连接条件指定为$R$和$S$中属性名相同的列做等值连接，因此$p$可省略.
    \end{itemize}
\end{solution}
\newpage
\begin{note}
    以$\mathbf{Student}$、$\mathbf{SC}$表为例，
    $$\mathbf{Student}\bowtie_{\mathrm{Student.Sno = SC.Sno}}\mathbf{SC}$$
    结果如下:
    \begin{figure}[!htpb]
        \centering
        \includegraphics[width=15cm]{images/sec2/2-3_Equijoin.pdf}
        \caption{等值连接}
        \label{fig2-3_1}
    \end{figure}

    而
    $$\mathbf{Student}\bowtie\mathbf{SC}$$
    结果如下:
    \begin{figure}[!htpb]
        \centering
        \includegraphics[width=15cm]{images/sec2/2-3_Natural_Join.pdf}
        \caption{自然连接}
        \label{fig2-3_2}
    \end{figure}
\end{note}

\begin{problem}
    关系代数的基本运算有哪些? 如何用这些基本运算来表示其他运算?
\end{problem}

\begin{solution}
    \begin{itemize}
        \item 基本运算:
        \begin{itemize}
            \item 选择($\sigma$):
                  $$\sigma_p(R) = \{t | t \in R \land p(t) = True\}$$
            \item 投影($\Pi$):
                  $$\Pi_{A_1,A_2,\ldots,A_k}(R) = \{t[A_1,A_2,\ldots,A_k] | t \in R\}$$
            \item 并($\bigcup$):
                  $$R\bigcup S = \{t | t\in R \lor t \in S\}$$
            \item 差($-$):
                  $$R - S = \{t | t\in R \land t \notin S\}$$
            \item 笛卡尔积($\times$):
                  $$R \times S = \{(t, q) | t\in R \land q \in S\}$$
        \end{itemize}
        \item 附加运算:
        \begin{itemize}
            \item 交($\bigcap$):
                  $$R\bigcap S = \{t | t\in R \land t \in S\}$$
                  满足:
                  $$R\bigcap S = R - (R - S)$$
            \item 连接($\bowtie$):
                  $$R\bowtie_p S = \{(t, q) | t \in R \land q \in S \land p\left((t, q)\right) = True\}$$
                  满足:
                  $$R\bowtie_p S = \sigma_p(R \times S)$$
            \item 除($\div$): \\
                  设$R(A_1,A_2,\ldots,A_m, B_1,B_2,\ldots,B_n)$和$S(B_1,B_2,\ldots,B_n, C_1,C_2,\ldots,C_k)$ 是两个关系，则$R \div S$的属性为$A_1,A_2,\ldots,A_m$，且:
                  $$R \div S = \{t | t\in \Pi_{A_1,A_2,\ldots,A_m}(R) \land (\forall q \in \Pi_{B_1,B_2,\ldots,B_n}(S), (t, q) \in R)\}$$
                  满足:
                  $$R \div S = \Pi_{A_1,A_2,\ldots,A_m}(R) - \Pi_{A_1,A_2,\ldots,A_m}((\Pi_{A_1,A_2,\ldots,A_m}(R) \times \Pi_{B_1,B_2,\ldots,B_n}(S)) - R)$$
        \end{itemize}
    \end{itemize}
\end{solution}

\newpage
\section{第三章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    有两个关系 $\mathbf{S}(A, B, C, D)$ 和 $\mathbf{T}(C, D, E, F)$, 写出与下列查询等价的 SQL 表达式:
    \begin{enumerate}[(1)]
        \item $\sigma_{A = 10}(\mathbf{S})$.
        \item $\Pi_{A, B}(\mathbf{S})$.
        \item $\mathbf{S} \bowtie \mathbf{T}$.
        \item $\mathbf{S} \mathop{\bowtie}\limits_{\mathbf{S}.C = \mathbf{T}.C} \mathbf{T}$.
        \item $\mathbf{S} \mathop{\bowtie}\limits_{A < E} \mathbf{T}$.
        \item  $\Pi_{C, D}(\mathbf{S}) \times \mathbf{T}$.
    \end{enumerate}
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-1_code}
            ]{./code/sec3/3-1-1.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-2_code}
            ]{./code/sec3/3-1-2.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-3_code}
            ]{./code/sec3/3-1-3.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-4_code}
            ]{./code/sec3/3-1-4.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-5_code}
            ]{./code/sec3/3-1-5.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-1-6_code}
            ]{./code/sec3/3-1-6.sql}
    \end{enumerate}
\end{solution}

\begin{problem}
    使用 SQL 语句建立(\hyperref[2-6]{题目2-6})中 SPJ 数据库的四个表($\mathbf{S}$、$\mathbf{P}$、$\mathbf{J}$和$\mathbf{SPJ}$)，并针对建立的四个表用 SQL 语句完成(\hyperref[2-6]{题目2-6})中的查询.
\end{problem}

\begin{solution}
    \begin{itemize}
        \item 建表:
            \begin{itemize}
                \item 建 $\mathbf{S}$ 表:
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-1_code}
                    ]{./code/sec3/3-2-1.sql}
                \item 建 $\mathbf{P}$ 表:
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-2_code}
                    ]{./code/sec3/3-2-2.sql}
                \item 建 $\mathbf{J}$ 表:
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-3_code}
                    ]{./code/sec3/3-2-3.sql}
                \newpage
                \item 建 $\mathbf{SPJ}$ 表:
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-4_code}
                    ]{./code/sec3/3-2-4.sql}
            \end{itemize}
        \item 查询:
            \begin{enumerate}[(1)]
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-5_code}
                    ]{./code/sec3/3-2-5.sql}
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-6_code}
                    ]{./code/sec3/3-2-6.sql}
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-7_code}
                    ]{./code/sec3/3-2-7.sql}
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-8_code}
                    ]{./code/sec3/3-2-8.sql}
                \newpage
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-2-9_code}
                    ]{./code/sec3/3-2-9.sql}
            \end{enumerate}
    \end{itemize}
\end{solution}

\begin{problem}
    针对(\hyperref[2-6]{题目2-6})中的四个表($\mathbf{S}$、$\mathbf{P}$、$\mathbf{J}$和$\mathbf{SPJ}$)，试用 SQL 完成以下各项操作:
    \begin{enumerate}[(1)]
        \item 找出所有供应商的姓名和所在城市.
        \item 找出所有零件的名称、颜色、重量.
        \item 找出使用供应商 S1 所供应零件的工程代码.
        \item 找出工程项目 J2 使用的各种零件的名称及其数量.
        \item 找出上海厂商供应的所有零件代码.
        \item 找出使用上海产的零件的工程名称.
        \item 找出没有使用天津产的零件的工程代码.
        \item 把全部红色零件的颜色改成蓝色.
        \item 把由 S5 供给 J2 的零件 P6 改为由 S3 供应.
        \item 从供应商关系中删除 S2 的记录，并从供应情况关系中删除相应的记录.
        \item 请将 (S2, J6, P4, 200) 插入供应情况关系.
    \end{enumerate}
\end{problem}

\newpage
\begin{solution}
    \begin{enumerate}[(1)]
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-1_code}
            ]{./code/sec3/3-3-1.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-2_code}
            ]{./code/sec3/3-3-2.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-3_code}
            ]{./code/sec3/3-3-3.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-4_code}
            ]{./code/sec3/3-3-4.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-5_code}
            ]{./code/sec3/3-3-5.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-6_code}
            ]{./code/sec3/3-3-6.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-7_code}
            ]{./code/sec3/3-3-7.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-8_code}
            ]{./code/sec3/3-3-8.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-9_code}
            ]{./code/sec3/3-3-9.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-10_code}
            ]{./code/sec3/3-3-10.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-3-11_code}
            ]{./code/sec3/3-3-11.sql}
        
    \end{enumerate}
\end{solution}

\newpage
\begin{problem}
    针对(\hyperref[2-6]{题目2-6})中的四个表($\mathbf{S}$、$\mathbf{P}$、$\mathbf{J}$和$\mathbf{SPJ}$)，为三建工程项目建立一个供应情况的视图，包括供应商代码(SNO)、零件代码(PNO)、供应数量(QTY). 针对该视图完成下列查询:
    \begin{enumerate}[(1)]
        \item 找出三建工程项目使用的各种零件代码及其数量.
        \item 找出供应商 S1 供应三建工程情况.
    \end{enumerate}
\end{problem}

\begin{solution}
    \begin{itemize}
        \item 创建视图:
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {3-4-1_code}
            ]{./code/sec3/3-4-1.sql}
        \item 查询
            \begin{enumerate}[(1)]
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-4-2_code}
                    ]{./code/sec3/3-4-2.sql}
                \item \ 
                    \lstinputlisting[
                        style       =   SQL,
                        % caption     =   {\bf probe.c},
                        label       =   {3-4-3_code}
                    ]{./code/sec3/3-4-3.sql}
            \end{enumerate}
    \end{itemize}
\end{solution}

\newpage
\section{第四章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    今有以下两个关系模式:
    $$\begin{aligned}
        & \text{\textbf{职工}(职工号, 姓名, 年龄, 职务, 工资, 部门号)};  \\
        & \text{\textbf{部门}(部门号, 名称, 经理名, 地址, 电话号)}. \\
    \end{aligned}$$
    请用 SQL 的 GRANT 语句和 REVOKE 语句(加上视图机制)实现以下授权定义和存取控制的功能:
    \begin{enumerate}[(1)]
        \item 用户王明对两个表有 SELECT 权限.
        \item 用户李勇对两个表有 INSERT 和 DELETE 权限.
        \item 每个职工只对自己的记录有 SELECT 权限.
        \item 用户刘星对职工表有 SELECT 权限，对``工资"字段具有更新权限.
        \item 用户张新具有修改这两个表的结构的权限.
        \item 用户周平具有对两个表的所有权限，并具有给其他用户授权的权限.
        \item 用户杨兰具有从每个部门职工中 SELECT 最高工资、最低工资、平均工资的权限，但不能查看每个人的工资.
    \end{enumerate}
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item \  
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-1_code}
            ]{./code/sec4/4-1-1.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-2_code}
            ]{./code/sec4/4-1-2.sql}
        \item \  
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-3_code}
            ]{./code/sec4/4-1-3.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-4_code}
            ]{./code/sec4/4-1-4.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-5_code}
            ]{./code/sec4/4-1-5.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-6_code}
            ]{./code/sec4/4-1-6.sql}
        \item \ 
            \lstinputlisting[
                style       =   SQL,
                % caption     =   {\bf probe.c},
                label       =   {4-1-7_code}
            ]{./code/sec4/4-1-7.sql}
    \end{enumerate}
\end{solution}

\newpage
\section{第五章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    假设有下面两个关系模式:
    $$\begin{aligned}
        & \text{\textbf{职工}(职工号, 姓名, 出生日期, 职务, 工资, 部门号), 其中职工号为主码};  \\
        & \text{\textbf{部门}(部门号, 名称, 经理姓名, 电话), 其中部门号为主码}. \\
    \end{aligned}$$
    用 SQL 定义这两个关系模式，要求在模式中完成以下完整性约束的定义:
    \begin{enumerate}[(1)]
        \item 定义每个模式的主码.
        \item 定义参照完整性约束.
        \item 定义职工年龄不超过 65 岁.
    \end{enumerate}
\end{problem}

\begin{solution}
    \lstinputlisting[
        style       =   SQL,
        % caption     =   {\bf probe.c},
        label       =   {5-1-1_code}
    ]{./code/sec5/5-1-1.sql}
\end{solution}

\newpage
\section{第六章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    理解并给出下列术语的定义:
    
    函数依赖、部分函数依赖、完全函数依赖、传递依赖、候选码、超码、主码、外码、全码、1NF、2NF、3NF、BCNF、多值依赖、4NF.
\end{problem}

\begin{solution}
    \begin{itemize}
        \item 函数依赖: 
            \begin{itemize}
                \item 对一关系$R(U)$, $X$和$Y$是其列集合$U$的子集，$t$和$l$分别是$R$中的任意两个元组.
                \item 如果$t[X] = l[X]$, 则$t[Y] = l[Y]$，\textbf{\red 那么称$Y$函数依赖于$X$, 或者$X$函数决定$Y$, 记为$X \rightarrow Y$}.
                \item 如果$Y$不依赖于$X$，则记为$X \not\rightarrow Y$. 如果$X \rightarrow Y$且$Y \rightarrow X$, 则$X$与$Y$一一对应，记为$X \leftrightarrow Y$
            \end{itemize}
        \item 完全函数依赖和部分函数依赖: 
            \begin{itemize}
                \item 假设$X$和$Y$是关系$R(U)$属性集$U$的不同子集，如有$X \rightarrow Y$且不存在$X$的真子集$X'$, 使得$X' \rightarrow Y$, 则有$X \xrightarrow{f} Y$, 称$Y$\textbf{\red 完全函数依赖}于$X$; 否则，记为$X \xrightarrow{p} Y$, 称作$Y$\textbf{\red 部分函数依赖}于$X$.
            \end{itemize}
        \item 传递依赖: 
            \begin{itemize}
                \item 如果$X$、$Y$和$Z$分别是关系$R(U)$不同的列属性集合，如果存在$X \rightarrow Y$, $Y \not\rightarrow X$, $Y \rightarrow Z$, 则称$Z$对$X$有\textbf{\red 传递函数依赖}.
            \end{itemize}
        \item 超码和候选码:
            \begin{itemize}
                \item 如果\uline{某一属性}或者\uline{某属性集合}可以唯一地标识不同的元组，则称这样的属性或者属性集为\textbf{\red 超码}.
                \item 不含有多余属性的超码为\textbf{\red 候选码}，一个超码去除任意一个属性就不再是超码了.
            \end{itemize}
        \item 主码: 
            \begin{itemize}
                \item 一个关关系可能有一个或多个候选键，在定义关系数据库关系表的时候，一般选择一个最合适的候选键作为\textbf{\red 主码}，主码的不同取值必须唯一标识不同的元组.
            \end{itemize}
        \item 外码: 
            \begin{itemize}
                \item 关系模式$R$属性或属性组$X$并非$R$的主码，但是另一个关系模式的主码，则称$X$是$R$的外部码，也称\textbf{\red 外码}.
            \end{itemize}
        \item 全码: 
            \begin{itemize}
                \item 整个属性组是码，称为\textbf{\red 全码}(all-key).
            \end{itemize}
        \item 第一范式(1NF): 
            \begin{itemize}
                \item 关系$R$的每一属性都是不可再分的基本数据项，同一属性中不能有多个值，即关系表中的某个属性不能有多个值或者不能有重复的属性.
            \end{itemize}
        \item 第二范式(2NF): 
            \begin{itemize}
                \item 关系$R$首先要满足第一范式，并且每一个\textbf{\red 非主属性都完全函数依赖于任何一个候选码}.
            \end{itemize}
        \item 第三范式(3NF): 
            \begin{itemize}
                \item 关系$R$满足第一范式，并且\textbf{\red 不存在非主属性对候选码的传递函数依赖}.
            \end{itemize}
        \item 巴斯-科德范式(BCNF): 
            \begin{itemize}
                \item 关系$R$在满足第一范式的基础上，\textbf{\red 不存在\uline{任何属性}对候选码的传递函数依赖}
            \end{itemize}
        \item 多值依赖:
            \begin{itemize}
                \item 对于关系$R$的属性集$U$, 设$X$和$Y$是$U$的子集，$Z = U - X - Y$, 令$(x, y, z)$表示属性集$(X, Y, Z)$的元组. 如果存在$(x, y_1, z_1)$和$(x, y_2, z_2)$时，也存在$(x, y_1, z_2)$和$(x, y_2, z_1)$, 那么称\textbf{\red 多值函数依赖}$X \rightarrow\rightarrow Y$在关系$R$上成立.
            \end{itemize}
        \item 第四范式(4NF): 
            \begin{itemize}
                \item 关系$R$在满足巴斯-科德范式的基础上，消除了多值依赖.
            \end{itemize} 
    \end{itemize}
\end{solution}

\begin{problem}
    建立一个包含系、学生、班级、学会等信息的关系数据库.
    \begin{itemize}
        \item 描述学生的属性有: 学号、姓名、 出生年月、系名、班号、宿舍区.
        \item 描述班级的属性有: 班号、专业名、系名、人数、入校年份.
        \item 描述系的属性有: 系名、系号、系办公室地点、人数.
        \item 描述学会的属性有:学会名 、成立年份、地点、人数.
    \end{itemize}
    有关语义如下: 一个系有若干专业，每个专业每年只招一个班，每个班有若干学生. 一个系的学生住在同一宿舍区. 每个学生可参加若干学会，每个学会有若干学生. 学生参加某学会有一个入会年份.
    
    请给出关系模式，写出每个关系模式的最小依赖集，指出是否存在传递函数依赖，对于函数依赖左部是多属性的情况，讨论函数依赖是完全函数依赖，还是部分函数依赖.
\end{problem}

\begin{solution}
    关系模式如下:
    $$
        \begin{array}{ll}
            \text{学生: }      & S(Sno, Sname, Sbirth, Dname, Cno, Rno) \\
            \text{班级: }      & C(Cno, Major, Dname, Cnum, Cyear) \\
            \text{系: }        & D(Dno, Dname, Daddr, Dnum) \\
            \text{学会: }      & P(Pname, Pyear, Paddr, Pnum) \\
            \text{学生-学会: } & SP(Sno, Pname, SPyear)
        \end{array}
    $$
    每个关系模式的最小依赖集如下:
    \begin{itemize}
        \item $S$: 
            $$
                \begin{aligned}
                    F_m = \{
                        & Sno \rightarrow Sname, Sno \rightarrow Sbirth, Sno \rightarrow Cno, \\
                        & Cno \rightarrow Dname, Dname \rightarrow Rno \}
                \end{aligned}
            $$
        \item $C$:
            $$
                \begin{aligned}
                    F_m = \{
                    & Cno \rightarrow Major, Cno \rightarrow Cnum, Cno \rightarrow Cyear, \\
                    & Major \rightarrow Dname, (Major, Cyear) \rightarrow Cno \}
                \end{aligned}
            $$
        \item $D$:
            $$
                \begin{aligned}
                    F_m = \{
                    & Dno \rightarrow Dname, Dno \rightarrow Daddr, Dno \rightarrow Dnum, \\
                    & Dname \rightarrow Dno \}
                \end{aligned}
            $$
        \item $P$:
            $$
                \begin{aligned}
                    F_m = \{
                    & Pname \rightarrow Pyear, Pname \rightarrow Paddr, \\
                    & Pname \rightarrow Pnum \}
                \end{aligned}
            $$
        \item $SP$:
            $$
                \begin{aligned}
                    F_m = \{
                    & (Sno, Pname) \rightarrow SPyear \}
                \end{aligned}
            $$
    \end{itemize}
    \newpage
    传递函数依赖如下:
        \begin{itemize}
            \item $S$中存在传递函数依赖
                $$Sno \rightarrow Dname, Sno \rightarrow Rno, Cno \rightarrow Rno$$
            \item $C$中存在传递函数依赖
                $$Cno \rightarrow Dname$$
        \end{itemize}
    共有两个函数依赖左部是多属性的情况:
        \begin{itemize}
            \item $C$中$(Major, Cyear) \rightarrow Cno$, 去掉左部的任意一个属性，则无法推导出右部属性，所以该函数依赖是完全函数依赖.
            \item $SP$中$(Sno, Pname) \rightarrow SPyear$, 去掉左部的任意一个属性，则无法推导出右部属性，所以该函数依赖是完全函数依赖.
        \end{itemize}
\end{solution}

\begin{problem}
    下面的结论哪些是正确的? 哪些是错误的? 对于错误的请给出理由或一个反例说明之.
    \begin{enumerate}[(1)]
        \item 任何一个二目关系是属于3NF的.
        \item 任何一个二目关系是属于BCNF的.
        \item 任何一个二目关系是属于4NF的.
        \item 当且仅当函数依赖$A \rightarrow B$在$R$上成立，关系$R(A, B, C)$等于其投影$R_1(A, B)$和$R_2(A, C)$的连接.
        \item 若$R.A \rightarrow R.B, R.B \rightarrow R.C$, 则$R.A \rightarrow R.C$.
        \item 若$R.A \rightarrow R.B, R.A \rightarrow R.C$, 则$R.A \rightarrow R.(B, C)$.
        \item 若$R.B \rightarrow R.A, R.C \rightarrow R.A$, 则$R.(B, C) \rightarrow R.A$.
        \item 若$R.(B, C) \rightarrow R.A$, 则$R.B \rightarrow R.A, R.C \rightarrow R.A$.
    \end{enumerate}
\end{problem}

\begin{solution}
    (1)、(2)、(3)、(5)、(6)、(7)正确，(4)、(8)错误，错误理由如下:
    \begin{description}
        \item[(4)] 根据\hyperref[note6.4]{本题注记中的定理}可知，若$A \rightarrow C$成立而$A \rightarrow B$不成立，关系$R(A, B, C)$依旧等于其投影$R_1(A, B)$和$R_2(A, C)$的连接. 题目中的\textbf{当且仅当}错误.
        \item[(8)] 反例: 以关系模式$SC(Sno, Cno, Grade)$为例，有函数依赖$(Sno, Cno) \rightarrow Grade$, 但$Sno \rightarrow Grade$, $Cno \rightarrow Grade$均不成立.
    \end{description}
\end{solution}

\begin{note}\label{note6.4}
    对于关系模式的等价分解，存在一个保持分解无损依赖的定理:

    设$\rho = \{ R_1, R_2 \}$是关系模式$R$的一个分解，$F$是$R$的函数依赖集，那么$\rho$是$R$(关于$F$)的无损分解的充分必要条件是:
    $$(R_1 \bigcap R_2) \rightarrow R_1 - R_2 \in F^+ \text{或} (R_1 \bigcap R_2) \rightarrow R_2 - R_1 \in F^+$$
\end{note}

\begin{problem}
    证明:
    \begin{enumerate}[(1)]
        \item 如果$R$是BCNF关系模式，则$R$是3NF关系模式，反之则不然.
        \item 如果$R$是3NF关系模式，则$R$一定是2NF关系模式.
    \end{enumerate}
\end{problem}

\begin{solution}
        \begin{enumerate}[(1)]
            \item 
                \begin{proof} 
                    首先证明: 若$R\in$ BCNF, 则$R\in$ 3NF.\newline
                    假设$R\in$ BCNF, 但$R\not\in$ 3NF, 由3NF的定义可知:\newline 
                    $R$中存在候选码$X$, 属性组$Y$和非主属性$Z$, 满足
                    $$X \rightarrow Y, Y \rightarrow Z$$
                    其中$$Y \not\rightarrow X, Z \not\rightarrow X, Z \not\rightarrow Y$$
                    由于$Y \not\rightarrow X$, 所以$Y$不可能包含$R$的码，但$Y \rightarrow Z$成立.
                    根据BCNF的定义，$R\not\in$ BCNF, 与假设矛盾.\newline
                    所以若$R\in$ BCNF, 则一定有$R\in$ 3NF.\par
                    接下来证明: $R\in$ 3NF, 但不一定有$R\in$ BCNF.\newline
                    若$R$中存在主属性对码的部分函数依赖或传递函数依赖，\newline
                    则$R\in$ 3NF, 但$R\not\in$ BCNF.
                \end{proof}
            \item 
                \begin{proof}
                    假设$R\in$ 3NF, 但$R\not\in$ 2NF, 由2NF的定义可知:\newline
                    $R$中存在非主属性$Z$部分函数依赖于候选码$X$, 即$X \xrightarrow{p} Z$.\newline
                    根据部分函数依赖的定义，$R$中存在$X$的真子集$X' \subset X$, 满足
                    $$X' \rightarrow Z$$.
                    于是$R$中存在候选码$X$, 属性组$X'$和非主属性$Z$, 满足
                    $$X \rightarrow X', X' \rightarrow Z$$
                    其中$$X' \not\rightarrow X, Z \not\rightarrow X, Z \not\rightarrow X'$$
                    根据3CNF的定义，$R\not\in$ 3NF, 与假设矛盾.\newline
                    所以若$R\in$ 3NF, 则一定有$R\in$ 2NF.
                \end{proof}
        \end{enumerate}
\end{solution}

\newpage
\section{第七章作业}
% 计数器置零
\setcounter{problemname}{0}

\begin{problem}
    需求分析阶段得到的数据字典的内容和作用是什么？
\end{problem}
    
\begin{solution}
    \begin{enumerate}[(1)]
        \item 数据字典的内容: 通常名括数据项、数据结称、数据流、数据存储和处理过程5个部分. 其中数据项是数据的最小组成单位，若干个数据项可以组成一个数据结构. 数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容.
        \item 数据字典的作用: 数据字典是关于数据库中的数据的描述，在需求分析建立，是下一步进行概念设计的基础，并在数据库的设计过程中不断修改、充实和完善.
    \end{enumerate}
\end{solution}

\begin{problem}
    规范化理论对数据库设计有什么指导意义？
\end{problem}

\begin{solution}
    \begin{enumerate}[(1)]
        \item 降低数据存储和维护数据一致性的成本. 即减少数据冗余，减少储存空间的开销; 当数据发生更新(以及插入和删除)的时候，不必同时更新那些冗余数据，降低了维护数据一致性的成本.
        \item 便于设计合理的关系表间的依赖和约束关系，便于实现数据完整性和一致性，避免插入异常、删除异常、更新异常.
        \item 便于设计合理的数据库结构，以提高数据库系统的整体性能，如提高查询效率等.
    \end{enumerate}
\end{solution}

\begin{note}
    \begin{figure}[!htpb]
        \centering
        \includegraphics[width=12.5cm]{images/sec7/7-3_concept.pdf}
        \caption{重要概念之间的关系}
        \label{concept}
    \end{figure}
\end{note}

\begin{problem}
    某工厂生产若干产品，每种产品由不同的零件组成，有的零件可用在不同的产品上. 这些零件由不同的原材料制成，不同零件所用的材料可以相同. 这些零件按所属的不同产品分别放在仓库中，原材料按照类别放在若干仓库中. 请用E-R图画出此工厂产品、零件、材料、仓库的概念模型.
\end{problem}

\begin{solution}
    \hyperref[ERD]{E-R图}如下所示:
    \begin{figure}[!htpb]
        \centering
        \includegraphics[width=13cm]{images/sec7/7-2_ER Diagram.pdf}
        \caption{E-R图}
        \label{ERD}
    \end{figure}
\end{solution}

% \newpage
% \section{第x章作业}
% % 计数器置零
% \setcounter{problemname}{0}

% \begin{problem}

% \end{problem}

% \begin{solution}

% \end{solution}

\end{document}